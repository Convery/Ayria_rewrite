/*
    Initial author: Convery (tcn@ayria.se)
    Started: 2023-01-20
    License: MIT

    This "disassembler" is limited in many ways, it's only reliable for
    getting the length of an instruction. It does not validate anything
    and will produce invalid results on obfuscated code that abuses the
    fact that the CPU will ignore certain instructions / prefixes.

    The XOP opcodemaps (8, 9, 10) can probably be safely ignored, but
    are included incase someone wants to use this for PS4/XB1 code.

    3DNow! instructions and 16-bit adressing is omitted.
*/

#pragma once
#include <Utilities/Utilities.hpp>

namespace Hacking
{
    // Forward declaration for readability.
    namespace Disassembler { static std::optional<uint8_t> Instructionlength(std::span<const uint8_t> Input); }

    // Decode until we have at least N bytes.
    inline std::optional<size_t> getInstructionboundry(std::span<const uint8_t> Input, size_t Minimumsize)
    {
        size_t Current = 0;

        while (Current < Minimumsize)
        {
            const auto Subspan = Input.subspan(Current, 18);
            const auto Length = Disassembler::Instructionlength(Subspan);
            if (!Length)
            {
                std::string Output = "Failed to decode instruction:";
                for (const auto &Byte : Subspan) Output += va(" %02X", Byte);
                Debugprint(Output);

                return std::nullopt;
            }

            Current += *Length;
        }

        return Current;
    }
    inline std::optional<size_t> getInstructionboundry(const uint8_t *Input, size_t Minimumsize)
    {
        return getInstructionboundry(std::span(Input, Minimumsize * 2), Minimumsize);
    }
    inline std::optional<size_t> getInstructionboundry(std::uintptr_t Input, size_t Minimumsize)
    {
        return getInstructionboundry(std::span((const uint8_t *)Input, Minimumsize * 2), Minimumsize);
    }

    namespace Disassembler
    {
        union Metadata_t { uint8_t RAW; struct { uint8_t ModRM : 1, IMM : 3; }; };

        // Lookup based on the current architecture, tuple<REXW / CS, 66 / 67, None>
        inline std::tuple<uint8_t, uint8_t, uint8_t> Lookup(uint8_t Opcode, uint8_t Map)
        {
            const auto Key = (uint16_t(Map) << 8) | uint16_t(Opcode);

            if constexpr (Build::is64bit)
            {
                constexpr auto TypeC48 = std::to_array<uint16_t>({ 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF });
                constexpr auto TypeF48 = std::to_array<uint16_t>({ 0x5, 0xD, 0x15, 0x1D, 0x25, 0x2D, 0x35, 0x3D, 0x68, 0xA9 });
                constexpr auto TypeF59 = std::to_array<uint16_t>({ 0x69, 0x81, 0xC7 });
                constexpr auto TypeF8C = std::to_array<uint16_t>({ 0xA0, 0xA1, 0xA2, 0xA3 });
                constexpr auto TypeFF0 = std::to_array<uint16_t>({ 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x6C, 0x6D, 0x6E, 0x6F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xC3, 0xC9, 0xCB, 0xCC, 0xCF, 0xD6, 0xD7, 0xEC, 0xED, 0xEE, 0xEF, 0xF1, 0xF4, 0xF5, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0x105, 0x106, 0x107, 0x108, 0x109, 0x10B, 0x10E, 0x130, 0x131, 0x132, 0x133, 0x134, 0x135, 0x137, 0x13C, 0x13D, 0x13F, 0x177, 0x1A0, 0x1A1, 0x1A2, 0x1A8, 0x1A9, 0x1AA, 0x1C8, 0x1C9, 0x1CA, 0x1CB, 0x1CC, 0x1CD, 0x1CE, 0x1CF });
                constexpr auto TypeFF1 = std::to_array<uint16_t>({ 0x0, 0x1, 0x2, 0x3, 0x8, 0x9, 0xA, 0xB, 0x10, 0x11, 0x12, 0x13, 0x18, 0x19, 0x1A, 0x1B, 0x20, 0x21, 0x22, 0x23, 0x28, 0x29, 0x2A, 0x2B, 0x30, 0x31, 0x32, 0x33, 0x38, 0x39, 0x3A, 0x3B, 0x63, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0xD0, 0xD1, 0xD2, 0xD3, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xFE, 0xFF, 0x100, 0x101, 0x102, 0x103, 0x10D, 0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x11A, 0x11B, 0x11C, 0x11D, 0x11E, 0x11F, 0x120, 0x121, 0x122, 0x123, 0x128, 0x129, 0x12A, 0x12B, 0x12C, 0x12D, 0x12E, 0x12F, 0x140, 0x141, 0x142, 0x143, 0x144, 0x145, 0x146, 0x147, 0x148, 0x149, 0x14A, 0x14B, 0x14C, 0x14D, 0x14E, 0x14F, 0x150, 0x151, 0x152, 0x153, 0x154, 0x155, 0x156, 0x157, 0x158, 0x159, 0x15A, 0x15B, 0x15C, 0x15D, 0x15E, 0x15F, 0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167, 0x168, 0x169, 0x16A, 0x16B, 0x16C, 0x16D, 0x16E, 0x16F, 0x174, 0x175, 0x176, 0x178, 0x179, 0x17A, 0x17B, 0x17C, 0x17D, 0x17E, 0x17F, 0x190, 0x191, 0x192, 0x193, 0x194, 0x195, 0x196, 0x197, 0x198, 0x199, 0x19A, 0x19B, 0x19C, 0x19D, 0x19E, 0x19F, 0x1A3, 0x1A5, 0x1A6, 0x1A7, 0x1AB, 0x1AD, 0x1AE, 0x1AF, 0x1B0, 0x1B1, 0x1B2, 0x1B3, 0x1B4, 0x1B5, 0x1B6, 0x1B7, 0x1B9, 0x1BB, 0x1BC, 0x1BD, 0x1BE, 0x1BF, 0x1C0, 0x1C1, 0x1C3, 0x1C7, 0x1D0, 0x1D1, 0x1D2, 0x1D3, 0x1D4, 0x1D5, 0x1D6, 0x1D7, 0x1D8, 0x1D9, 0x1DA, 0x1DB, 0x1DC, 0x1DD, 0x1DE, 0x1DF, 0x1E0, 0x1E1, 0x1E2, 0x1E3, 0x1E4, 0x1E5, 0x1E6, 0x1E7, 0x1E8, 0x1E9, 0x1EA, 0x1EB, 0x1EC, 0x1ED, 0x1EE, 0x1EF, 0x1F0, 0x1F1, 0x1F2, 0x1F3, 0x1F4, 0x1F5, 0x1F6, 0x1F7, 0x1F8, 0x1F9, 0x1FA, 0x1FB, 0x1FC, 0x1FD, 0x1FE, 0x1FF, 0x200, 0x201, 0x202, 0x203, 0x204, 0x205, 0x206, 0x207, 0x208, 0x209, 0x20A, 0x20B, 0x20C, 0x20D, 0x20E, 0x20F, 0x210, 0x211, 0x212, 0x213, 0x214, 0x215, 0x216, 0x217, 0x218, 0x219, 0x21A, 0x21B, 0x21C, 0x21D, 0x21E, 0x21F, 0x220, 0x221, 0x222, 0x223, 0x224, 0x225, 0x226, 0x227, 0x228, 0x229, 0x22A, 0x22B, 0x22C, 0x22D, 0x22E, 0x22F, 0x230, 0x231, 0x232, 0x233, 0x234, 0x235, 0x236, 0x237, 0x238, 0x239, 0x23A, 0x23B, 0x23C, 0x23D, 0x23E, 0x23F, 0x240, 0x241, 0x242, 0x243, 0x244, 0x245, 0x246, 0x247, 0x249, 0x24B, 0x24C, 0x24D, 0x24E, 0x24F, 0x250, 0x251, 0x252, 0x253, 0x254, 0x255, 0x258, 0x259, 0x25A, 0x25B, 0x25C, 0x25E, 0x262, 0x263, 0x264, 0x265, 0x266, 0x268, 0x270, 0x271, 0x272, 0x273, 0x275, 0x276, 0x277, 0x278, 0x279, 0x27A, 0x27B, 0x27C, 0x27D, 0x27E, 0x27F, 0x280, 0x281, 0x282, 0x283, 0x288, 0x289, 0x28A, 0x28B, 0x28C, 0x28D, 0x28E, 0x28F, 0x290, 0x291, 0x292, 0x293, 0x296, 0x297, 0x298, 0x299, 0x29A, 0x29B, 0x29C, 0x29D, 0x29E, 0x29F, 0x2A0, 0x2A1, 0x2A2, 0x2A3, 0x2A6, 0x2A7, 0x2A8, 0x2A9, 0x2AA, 0x2AB, 0x2AC, 0x2AD, 0x2AE, 0x2AF, 0x2B4, 0x2B5, 0x2B6, 0x2B7, 0x2B8, 0x2B9, 0x2BA, 0x2BB, 0x2BC, 0x2BD, 0x2BE, 0x2BF, 0x2C4, 0x2C6, 0x2C7, 0x2C8, 0x2C9, 0x2CA, 0x2CB, 0x2CC, 0x2CD, 0x2CF, 0x2D8, 0x2DB, 0x2DC, 0x2DD, 0x2DE, 0x2DF, 0x2F0, 0x2F1, 0x2F2, 0x2F3, 0x2F5, 0x2F6, 0x2F7, 0x2F8, 0x2F9, 0x2FA, 0x2FB, 0x348, 0x349, 0x34A, 0x34B, 0x34C, 0x35C, 0x35D, 0x35E, 0x35F, 0x368, 0x369, 0x36A, 0x36B, 0x36C, 0x36D, 0x36E, 0x36F, 0x378, 0x379, 0x37A, 0x37B, 0x37C, 0x37D, 0x37E, 0x37F, 0x510, 0x511, 0x51D, 0x52A, 0x52C, 0x52D, 0x52E, 0x52F, 0x551, 0x558, 0x559, 0x55A, 0x55B, 0x55C, 0x55D, 0x55E, 0x55F, 0x56E, 0x578, 0x579, 0x57A, 0x57B, 0x57C, 0x57D, 0x57E, 0x613, 0x62C, 0x62D, 0x642, 0x643, 0x64C, 0x64D, 0x64E, 0x64F, 0x656, 0x657, 0x696, 0x697, 0x698, 0x699, 0x69A, 0x69B, 0x69C, 0x69D, 0x69E, 0x69F, 0x6A6, 0x6A7, 0x6A8, 0x6A9, 0x6AA, 0x6AB, 0x6AC, 0x6AD, 0x6AE, 0x6AF, 0x6B6, 0x6B7, 0x6B8, 0x6B9, 0x6BA, 0x6BB, 0x6BC, 0x6BD, 0x6BE, 0x6BF, 0x6D6, 0x6D7, 0x885, 0x886, 0x887, 0x88E, 0x88F, 0x895, 0x896, 0x897, 0x89E, 0x89F, 0x8A2, 0x8A3, 0x8A6, 0x8B6, 0x901, 0x902, 0x912, 0x980, 0x981, 0x982, 0x983, 0x990, 0x991, 0x992, 0x993, 0x994, 0x995, 0x996, 0x997, 0x998, 0x999, 0x99A, 0x99B, 0x9C1, 0x9C2, 0x9C3, 0x9C6, 0x9C7, 0x9CB, 0x9D1, 0x9D2, 0x9D3, 0x9D6, 0x9D7, 0x9DB, 0x9E1, 0x9E2, 0x9E3 });
                constexpr auto TypeFF2 = std::to_array<uint16_t>({ 0x4, 0xC, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C, 0x6A, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0xA8, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xCD, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xEB });
                constexpr auto TypeFF3 = std::to_array<uint16_t>({ 0x6B, 0x80, 0x83, 0xC0, 0xC1, 0xC6, 0x170, 0x171, 0x172, 0x173, 0x1A4, 0x1AC, 0x1BA, 0x1C2, 0x1C4, 0x1C5, 0x1C6, 0x300, 0x301, 0x302, 0x303, 0x304, 0x305, 0x306, 0x308, 0x309, 0x30A, 0x30B, 0x30C, 0x30D, 0x30E, 0x30F, 0x314, 0x315, 0x316, 0x317, 0x318, 0x319, 0x31A, 0x31B, 0x31D, 0x31E, 0x31F, 0x320, 0x321, 0x322, 0x323, 0x325, 0x326, 0x327, 0x330, 0x331, 0x332, 0x333, 0x338, 0x339, 0x33A, 0x33B, 0x33E, 0x33F, 0x340, 0x341, 0x342, 0x343, 0x344, 0x346, 0x350, 0x351, 0x354, 0x355, 0x356, 0x357, 0x360, 0x361, 0x362, 0x363, 0x366, 0x367, 0x370, 0x371, 0x372, 0x373, 0x3C2, 0x3CC, 0x3CE, 0x3CF, 0x3DF, 0x3F0, 0x8C0, 0x8C1, 0x8C2, 0x8C3, 0x8CC, 0x8CD, 0x8CE, 0x8CF, 0x8EC, 0x8ED, 0x8EE, 0x8EF });
                constexpr auto TypeFF4 = std::to_array<uint16_t>({ 0xC2, 0xCA });
                constexpr auto TypeFF6 = std::to_array<uint16_t>({ 0xC8 });
                constexpr auto TypeFF8 = std::to_array<uint16_t>({ 0xE8, 0xE9, 0x180, 0x181, 0x182, 0x183, 0x184, 0x185, 0x186, 0x187, 0x188, 0x189, 0x18A, 0x18B, 0x18C, 0x18D, 0x18E, 0x18F });
                constexpr auto TypeFF9 = std::to_array<uint16_t>({ 0xA10, 0xA12 });

                if (std::ranges::contains(TypeC48, Key)) return { 0xC, 0x4, 0x8 };
                if (std::ranges::contains(TypeF48, Key)) return { 0xF, 0x4, 0x8 };
                if (std::ranges::contains(TypeF59, Key)) return { 0xF, 0x5, 0x9 };
                if (std::ranges::contains(TypeF8C, Key)) return { 0xF, 0x8, 0xC };
                if (std::ranges::contains(TypeFF0, Key)) return { 0xF, 0xF, 0x0 };
                if (std::ranges::contains(TypeFF1, Key)) return { 0xF, 0xF, 0x1 };
                if (std::ranges::contains(TypeFF2, Key)) return { 0xF, 0xF, 0x2 };
                if (std::ranges::contains(TypeFF3, Key)) return { 0xF, 0xF, 0x3 };
                if (std::ranges::contains(TypeFF4, Key)) return { 0xF, 0xF, 0x4 };
                if (std::ranges::contains(TypeFF6, Key)) return { 0xF, 0xF, 0x6 };
                if (std::ranges::contains(TypeFF8, Key)) return { 0xF, 0xF, 0x8 };
                if (std::ranges::contains(TypeFF9, Key)) return { 0xF, 0xF, 0x9 };
            }

            else
            {
                constexpr auto TypeF48 = std::to_array<uint16_t>({ 0x5, 0xD, 0x15, 0x1D, 0x25, 0x2D, 0x35, 0x3D, 0x68, 0xA0, 0xA1, 0xA2, 0xA3, 0xA9, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xE8, 0xE9, 0x180, 0x181, 0x182, 0x183, 0x184, 0x185, 0x186, 0x187, 0x188, 0x189, 0x18A, 0x18B, 0x18C, 0x18D, 0x18E, 0x18F, 0x1B8 });
                constexpr auto TypeF59 = std::to_array<uint16_t>({ 0x69, 0x81, 0xC7 });
                constexpr auto TypeF8C = std::to_array<uint16_t>({ 0x9A, 0xEA });
                constexpr auto TypeFF0 = std::to_array<uint16_t>({ 0x6, 0x7, 0xE, 0x16, 0x17, 0x1E, 0x1F, 0x27, 0x2F, 0x37, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x6C, 0x6D, 0x6E, 0x6F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xC3, 0xC9, 0xCB, 0xCC, 0xCE, 0xCF, 0xD6, 0xD7, 0xEC, 0xED, 0xEE, 0xEF, 0xF1, 0xF4, 0xF5, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0x105, 0x106, 0x107, 0x108, 0x109, 0x10B, 0x10E, 0x130, 0x131, 0x132, 0x133, 0x134, 0x135, 0x137, 0x139, 0x13C, 0x13D, 0x13F, 0x177, 0x1A0, 0x1A1, 0x1A2, 0x1A8, 0x1A9, 0x1AA, 0x1C8, 0x1C9, 0x1CA, 0x1CB, 0x1CC, 0x1CD, 0x1CE, 0x1CF });
                constexpr auto TypeFF1 = std::to_array<uint16_t>({ 0x0, 0x1, 0x2, 0x3, 0x8, 0x9, 0xA, 0xB, 0x10, 0x11, 0x12, 0x13, 0x18, 0x19, 0x1A, 0x1B, 0x20, 0x21, 0x22, 0x23, 0x28, 0x29, 0x2A, 0x2B, 0x30, 0x31, 0x32, 0x33, 0x38, 0x39, 0x3A, 0x3B, 0x62, 0x63, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0xC4, 0xC5, 0xD0, 0xD1, 0xD2, 0xD3, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xFE, 0xFF, 0x100, 0x101, 0x102, 0x103, 0x10D, 0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x11A, 0x11B, 0x11C, 0x11D, 0x11E, 0x11F, 0x120, 0x121, 0x122, 0x123, 0x124, 0x126, 0x128, 0x129, 0x12A, 0x12B, 0x12C, 0x12D, 0x12E, 0x12F, 0x140, 0x141, 0x142, 0x143, 0x144, 0x145, 0x146, 0x147, 0x148, 0x149, 0x14A, 0x14B, 0x14C, 0x14D, 0x14E, 0x14F, 0x150, 0x151, 0x152, 0x153, 0x154, 0x155, 0x156, 0x157, 0x158, 0x159, 0x15A, 0x15B, 0x15C, 0x15D, 0x15E, 0x15F, 0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167, 0x168, 0x169, 0x16A, 0x16B, 0x16C, 0x16D, 0x16E, 0x16F, 0x174, 0x175, 0x176, 0x178, 0x179, 0x17A, 0x17B, 0x17C, 0x17D, 0x17E, 0x17F, 0x190, 0x191, 0x192, 0x193, 0x194, 0x195, 0x196, 0x197, 0x198, 0x199, 0x19A, 0x19B, 0x19C, 0x19D, 0x19E, 0x19F, 0x1A3, 0x1A5, 0x1A6, 0x1A7, 0x1AB, 0x1AD, 0x1AE, 0x1AF, 0x1B0, 0x1B1, 0x1B2, 0x1B3, 0x1B4, 0x1B5, 0x1B6, 0x1B7, 0x1B9, 0x1BB, 0x1BC, 0x1BD, 0x1BE, 0x1BF, 0x1C0, 0x1C1, 0x1C3, 0x1C7, 0x1D0, 0x1D1, 0x1D2, 0x1D3, 0x1D4, 0x1D5, 0x1D6, 0x1D7, 0x1D8, 0x1D9, 0x1DA, 0x1DB, 0x1DC, 0x1DD, 0x1DE, 0x1DF, 0x1E0, 0x1E1, 0x1E2, 0x1E3, 0x1E4, 0x1E5, 0x1E6, 0x1E7, 0x1E8, 0x1E9, 0x1EA, 0x1EB, 0x1EC, 0x1ED, 0x1EE, 0x1EF, 0x1F0, 0x1F1, 0x1F2, 0x1F3, 0x1F4, 0x1F5, 0x1F6, 0x1F7, 0x1F8, 0x1F9, 0x1FA, 0x1FB, 0x1FC, 0x1FD, 0x1FE, 0x1FF, 0x200, 0x201, 0x202, 0x203, 0x204, 0x205, 0x206, 0x207, 0x208, 0x209, 0x20A, 0x20B, 0x20C, 0x20D, 0x20E, 0x20F, 0x210, 0x211, 0x212, 0x213, 0x214, 0x215, 0x216, 0x217, 0x218, 0x219, 0x21A, 0x21B, 0x21C, 0x21D, 0x21E, 0x21F, 0x220, 0x221, 0x222, 0x223, 0x224, 0x225, 0x226, 0x227, 0x228, 0x229, 0x22A, 0x22B, 0x22C, 0x22D, 0x22E, 0x22F, 0x230, 0x231, 0x232, 0x233, 0x234, 0x235, 0x236, 0x237, 0x238, 0x239, 0x23A, 0x23B, 0x23C, 0x23D, 0x23E, 0x23F, 0x240, 0x241, 0x242, 0x243, 0x244, 0x245, 0x246, 0x247, 0x24C, 0x24D, 0x24E, 0x24F, 0x250, 0x251, 0x252, 0x253, 0x254, 0x255, 0x258, 0x259, 0x25A, 0x25B, 0x262, 0x263, 0x264, 0x265, 0x266, 0x268, 0x270, 0x271, 0x272, 0x273, 0x275, 0x276, 0x277, 0x278, 0x279, 0x27A, 0x27B, 0x27C, 0x27D, 0x27E, 0x27F, 0x280, 0x281, 0x282, 0x283, 0x288, 0x289, 0x28A, 0x28B, 0x28C, 0x28D, 0x28E, 0x28F, 0x290, 0x291, 0x292, 0x293, 0x296, 0x297, 0x298, 0x299, 0x29A, 0x29B, 0x29C, 0x29D, 0x29E, 0x29F, 0x2A0, 0x2A1, 0x2A2, 0x2A3, 0x2A6, 0x2A7, 0x2A8, 0x2A9, 0x2AA, 0x2AB, 0x2AC, 0x2AD, 0x2AE, 0x2AF, 0x2B4, 0x2B5, 0x2B6, 0x2B7, 0x2B8, 0x2B9, 0x2BA, 0x2BB, 0x2BC, 0x2BD, 0x2BE, 0x2BF, 0x2C4, 0x2C6, 0x2C7, 0x2C8, 0x2C9, 0x2CA, 0x2CB, 0x2CC, 0x2CD, 0x2CF, 0x2D8, 0x2DB, 0x2DC, 0x2DD, 0x2DE, 0x2DF, 0x2F0, 0x2F1, 0x2F2, 0x2F3, 0x2F5, 0x2F6, 0x2F7, 0x2F8, 0x2F9, 0x2FA, 0x2FB, 0x348, 0x349, 0x34A, 0x34B, 0x34C, 0x35C, 0x35D, 0x35E, 0x35F, 0x368, 0x369, 0x36A, 0x36B, 0x36C, 0x36D, 0x36E, 0x36F, 0x378, 0x379, 0x37A, 0x37B, 0x37C, 0x37D, 0x37E, 0x37F, 0x510, 0x511, 0x51D, 0x52A, 0x52C, 0x52D, 0x52E, 0x52F, 0x551, 0x558, 0x559, 0x55A, 0x55B, 0x55C, 0x55D, 0x55E, 0x55F, 0x56E, 0x578, 0x579, 0x57A, 0x57B, 0x57C, 0x57D, 0x57E, 0x613, 0x62C, 0x62D, 0x642, 0x643, 0x64C, 0x64D, 0x64E, 0x64F, 0x656, 0x657, 0x696, 0x697, 0x698, 0x699, 0x69A, 0x69B, 0x69C, 0x69D, 0x69E, 0x69F, 0x6A6, 0x6A7, 0x6A8, 0x6A9, 0x6AA, 0x6AB, 0x6AC, 0x6AD, 0x6AE, 0x6AF, 0x6B6, 0x6B7, 0x6B8, 0x6B9, 0x6BA, 0x6BB, 0x6BC, 0x6BD, 0x6BE, 0x6BF, 0x6D6, 0x6D7, 0x885, 0x886, 0x887, 0x88E, 0x88F, 0x895, 0x896, 0x897, 0x89E, 0x89F, 0x8A2, 0x8A3, 0x8A6, 0x8B6, 0x901, 0x902, 0x912, 0x980, 0x981, 0x982, 0x983, 0x990, 0x991, 0x992, 0x993, 0x994, 0x995, 0x996, 0x997, 0x998, 0x999, 0x99A, 0x99B, 0x9C1, 0x9C2, 0x9C3, 0x9C6, 0x9C7, 0x9CB, 0x9D1, 0x9D2, 0x9D3, 0x9D6, 0x9D7, 0x9DB, 0x9E1, 0x9E2, 0x9E3 });
                constexpr auto TypeFF2 = std::to_array<uint16_t>({ 0x4, 0xC, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C, 0x6A, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0xA8, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xCD, 0xD4, 0xD5, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xEB });
                constexpr auto TypeFF3 = std::to_array<uint16_t>({ 0x6B, 0x80, 0x82, 0x83, 0xC0, 0xC1, 0xC6, 0x170, 0x171, 0x172, 0x173, 0x1A4, 0x1AC, 0x1BA, 0x1C2, 0x1C4, 0x1C5, 0x1C6, 0x300, 0x301, 0x302, 0x303, 0x304, 0x305, 0x306, 0x308, 0x309, 0x30A, 0x30B, 0x30C, 0x30D, 0x30E, 0x30F, 0x314, 0x315, 0x316, 0x317, 0x318, 0x319, 0x31A, 0x31B, 0x31D, 0x31E, 0x31F, 0x320, 0x321, 0x322, 0x323, 0x325, 0x326, 0x327, 0x330, 0x331, 0x332, 0x333, 0x338, 0x339, 0x33A, 0x33B, 0x33E, 0x33F, 0x340, 0x341, 0x342, 0x343, 0x344, 0x346, 0x350, 0x351, 0x354, 0x355, 0x356, 0x357, 0x360, 0x361, 0x362, 0x363, 0x366, 0x367, 0x370, 0x371, 0x372, 0x373, 0x3C2, 0x3CC, 0x3CE, 0x3CF, 0x3DF, 0x3F0, 0x8C0, 0x8C1, 0x8C2, 0x8C3, 0x8CC, 0x8CD, 0x8CE, 0x8CF, 0x8EC, 0x8ED, 0x8EE, 0x8EF });
                constexpr auto TypeFF4 = std::to_array<uint16_t>({ 0xC2, 0xCA });
                constexpr auto TypeFF6 = std::to_array<uint16_t>({ 0xC8 });
                constexpr auto TypeFF9 = std::to_array<uint16_t>({ 0xA10, 0xA12 });

                if (std::ranges::contains(TypeF48, Key)) return { 0xF, 0x4, 0x8 };
                if (std::ranges::contains(TypeF59, Key)) return { 0xF, 0x5, 0x9 };
                if (std::ranges::contains(TypeF8C, Key)) return { 0xF, 0x8, 0xC };
                if (std::ranges::contains(TypeFF0, Key)) return { 0xF, 0xF, 0x0 };
                if (std::ranges::contains(TypeFF1, Key)) return { 0xF, 0xF, 0x1 };
                if (std::ranges::contains(TypeFF2, Key)) return { 0xF, 0xF, 0x2 };
                if (std::ranges::contains(TypeFF3, Key)) return { 0xF, 0xF, 0x3 };
                if (std::ranges::contains(TypeFF4, Key)) return { 0xF, 0xF, 0x4 };
                if (std::ranges::contains(TypeFF6, Key)) return { 0xF, 0xF, 0x6 };
                if (std::ranges::contains(TypeFF9, Key)) return { 0xF, 0xF, 0x9 };
            }

            return { 0xFF, 0xFF, 0xFF };
        }

        // Parse ModRM / SIB.
        inline std::tuple<uint8_t, uint8_t, uint8_t> fromModRM(uint8_t Data)
        {
            return { (Data & 0xC0) >> 6, (Data & 0x38) >> 3, Data & 7 };
        }
        inline std::tuple<uint8_t, uint8_t, uint8_t> fromSIB(uint8_t Data)
        {
            return { (Data & 0xC0) >> 6, (Data & 0x38) >> 3, Data & 7 };
        }

        // Get the total length of the operand(s).
        inline uint8_t Operandlength(const Metadata_t Info, uint8_t MODRM, uint8_t SIB)
        {
            size_t Displacement{};

            if (Info.ModRM)
            {
                const auto [Scale, Index, Base] = fromSIB(SIB);
                const auto [Mod, Reg, RM] = fromModRM(MODRM);
                const auto useSIB = (RM == 4) && (Mod != 3);

                if (useSIB && Mod == 0 && Base == 5) Displacement = 4;
                else if (Mod == 0 && RM == 5) Displacement = 4;
                else if (Mod == 2) Displacement = 4;
                else if (Mod == 1) Displacement = 1;

                Displacement += useSIB;
            }

            // IMM is limited to 3 bits, so we need some hackery for x64.
            if constexpr (!Build::is64bit) return uint8_t(Info.ModRM + Displacement + Info.IMM);
            else return uint8_t(Info.ModRM + Displacement + (Info.IMM == 6 ? 8 : Info.IMM));
        }

        // Maximum length of a x86 instruction is 16 bytes. Worst case: we read 18 bytes.
        static std::optional<uint8_t> Instructionlength(std::span<const uint8_t> Input)
        {
            uint8_t REP{}, REX{}, SEG{}, OPEx{};
            uint8_t Opcodemap{}, Opcode{};
            uint8_t Offset{};

            // Parse the prefixes.
            while (true)
            {
                constexpr auto Segments = std::to_array<uint8_t>({ 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65 });
                constexpr auto REPNZ = std::to_array<uint8_t>({ 0xF0, 0xF2, 0xF3 });
                constexpr auto Size = std::to_array<uint8_t>({ 0x66, 0x67 });

                // REX has to be the last prefix, else it's ignored.
                if (std::ranges::contains(Segments, Input[Offset])) { SEG = Input[Offset++]; REX = 0; continue; }
                if (std::ranges::contains(REPNZ, Input[Offset])) { REP = Input[Offset++]; REX = 0; continue; }
                if (std::ranges::contains(Size, Input[Offset])) { OPEx = Input[Offset++]; REX = 0; continue; }

                // x86_64 only.
                if constexpr (Build::is64bit)
                {
                    if ((Input[Offset] & 0xF0) == 0x40)
                    {
                        REX = Input[Offset++];
                        continue;
                    }
                }

                break;
            }

            // Check the encoding type.
            constexpr auto Encoding = std::to_array<uint8_t>({ 0x62, 0x8F, 0xC4, 0xC5 });
            if (std::ranges::contains(Encoding, Input[Offset]))
            {
                do
                {
                    // x86 needs extra validation.
                    if constexpr (!Build::is64bit)
                    {
                        // VEX1 vs. LDS
                        if ((Input[Offset] == 0xC5) && 0xC0 != (Input[0] & 0xC0)) break;

                        // VEX2 vs. LES
                        if ((Input[Offset] == 0xC4) && 0xC0 != (Input[0] & 0xC0)) break;

                        // EVEX vs. BOUND
                        if ((Input[Offset] == 0x62) && 0 == (Input[0] & 0xF0)) break;

                        // XOP vs. POP
                        if ((Input[Offset] == 0x8F) && (Input[0] & 0x38)) break;
                    }

                    // Extract VEX for easier access.
                    const uint8_t B1{ Input[Offset + 1] }, B2{ Input[Offset + 2] };

                    // VEX1 encoding.
                    if (Input[Offset] == 0xC5)
                    {
                        // Unpack prefix.
                        if ((B1 & 3) == 1) OPEx = 0x66;
                        if ((B1 & 3) == 2) REP = 0xF3;
                        if ((B1 & 3) == 3) REP = 0xF2;

                        // Fixup REX.
                        REX = 0x40 | (B1 & 0x80) >> 5;
                        REX ^= 0x04;

                        // Constant map.
                        Opcodemap = 1;

                        // Skip to opcode.
                        Offset += 2;
                        break;
                    }

                    // VEX2 / XOP encoding.
                    if (Input[Offset] == 0xC4 || Input[Offset] == 0x8F)
                    {
                        // Unpack prefix.
                        if ((B2 & 3) == 1) OPEx = 0x66;
                        if ((B2 & 3) == 2) REP = 0xF3;
                        if ((B2 & 3) == 3) REP = 0xF2;

                        // Fixup REX.
                        REX = 0x40;
                        REX |= (B1 & 0x80) >> 5;       // R
                        REX |= (B1 & 0x40) >> 5;       // X
                        REX |= (B1 & 0x20) >> 5;       // B
                        REX |= (B2 & 0x80) >> 4;       // W
                        REX ^= 0x07;

                        // Get the map to use.
                        Opcodemap = (B1 & 0x0F);

                        // Skip to opcode.
                        Offset += 3;
                        break;
                    }

                    // EVEX / MVEX encoding.
                    if (Input[Offset] == 0x62)
                    {
                        // Unpack prefix.
                        if ((B2 & 3) == 1) OPEx = 0x66;
                        if ((B2 & 3) == 2) REP = 0xF3;
                        if ((B2 & 3) == 3) REP = 0xF2;

                        // Fixup REX.
                        REX = 0x40;
                        REX |= (B1 & 0x80) >> 5;       // R
                        REX |= (B1 & 0x40) >> 5;       // X
                        REX |= (B1 & 0x20) >> 5;       // B
                        REX |= (B2 & 0x80) >> 4;       // W
                        REX ^= 0x07;

                        // Get the map to use.
                        Opcodemap = (B1 & 0x04);

                        // Skip to opcode.
                        Offset += 4;
                        break;
                    }

                } while (false);
            }

            // Check if we need to change the map.
            if (Opcodemap == 0 && Input[Offset] == 0x0F) { Opcodemap = 1; ++Offset; }
            if (Opcodemap == 1 && Input[Offset] == 0x38) { Opcodemap = 2; ++Offset; }
            if (Opcodemap == 1 && Input[Offset] == 0x3A) { Opcodemap = 3; ++Offset; }

            // Unsupported maps (DREX, 3DNow!).
            if (Opcodemap == 1 && Input[Offset] == 0x0F) { return std::nullopt; }
            if (Opcodemap == 1 && Input[Offset] == 0x7A) { return std::nullopt; }
            if (Opcodemap == 1 && Input[Offset] == 0x7B) { return std::nullopt; }

            // Finally we get the opcode.
            Opcode = Input[Offset++];

            // Some opcodes do need manual handling.
            {
                // Mandatory 66 / F2, vcvttps2uqq / vcvttsd2usi
                if (Opcodemap == 1 && Opcode == 0x78 && (OPEx == 0x66 || REP == 0xF2))
                {
                    return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 2 }, Input[Offset], Input[Offset + 1]);
                }

                // Mandatory F3, POPCNT
                if (Opcodemap == 1 && Opcode == 0xB8 && REP == 0xF3)
                {
                    return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 0 }, Input[Offset], Input[Offset + 1]);
                }

                // Hetromorphic groups.
                if (Opcodemap == 0 && Opcode == 0xF6)
                {
                    const auto [Mod, OP, RM] = fromModRM(Input[Offset]);

                    if (OP < 2) return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 1 }, Input[Offset], Input[Offset + 1]);
                    return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 0 }, Input[Offset], Input[Offset + 1]);

                }
                if (Opcodemap == 0 && Opcode == 0xF7)
                {
                    const auto [Mod, OP, RM] = fromModRM(Input[Offset]);

                    if (OP < 2 && !OPEx) return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 4 }, Input[Offset], Input[Offset + 1]);
                    if (OP < 2 && OPEx) return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 2 }, Input[Offset], Input[Offset + 1]);
                    return Offset + Operandlength(Metadata_t{ .ModRM = 1, .IMM = 0 }, Input[Offset], Input[Offset + 1]);
                }
            }

            // Returns 0xFF for all on error, 0x0F on invalid.
            const auto CSW = (REX & 8) || (!Build::is64bit && SEG == 0x2E);
            const auto [pEX, uEX, Norm] = Lookup(Opcode, Opcodemap);
            if (Norm == 0xFF) return std::nullopt;

            // Select metadata based on the prefixes we've seen so far.
            if (uEX != 0x0F && OPEx) return Offset + Operandlength(Metadata_t{ .RAW = uEX }, Input[Offset], Input[Offset + 1]);
            if (pEX != 0x0F && CSW) return Offset + Operandlength(Metadata_t{ .RAW = pEX }, Input[Offset], Input[Offset + 1]);
            return Offset + Operandlength(Metadata_t{ .RAW = Norm }, Input[Offset], Input[Offset + 1]);
        }
    }
}
